/**
 * Integration tests for standard() operations with hook generation.
 * 
 * This test suite verifies that:
 * 1. standard() creates proper contracts with RouteBuilder metadata
 * 2. createRouterHooks() correctly detects operation types from standard() contracts
 * 3. Type safety is maintained end-to-end
 * 4. All CRUD operations generate the correct hook types
 */

import { describe, expect, it, vi, beforeEach, expectTypeOf } from 'vitest';
import { z } from 'zod/v4';
import { standard } from '../../standard/standard-operations';
import { createRouterHooks, defineInvalidations } from '../../hooks/generate-hooks';
import { ROUTE_METHOD_META_KEY } from '../../builder/mount-method';

// Mock TanStack Query hooks
const reactQueryMocks = vi.hoisted(() => ({
  useQuery: vi.fn(),
  useMutation: vi.fn(),
}));

vi.mock('@tanstack/react-query', () => reactQueryMocks);

// Test entity schema
const testEntitySchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string(),
  age: z.number().optional(),
  createdAt: z.date(),
  updatedAt: z.date(),
});

describe('standard() + createRouterHooks() Integration', () => {
  beforeEach(() => {
    reactQueryMocks.useQuery.mockReset();
    reactQueryMocks.useMutation.mockReset();
  });

  describe('Contract Creation with standard()', () => {
    it('should create contracts with RouteBuilder metadata', () => {
      const ops = standard(testEntitySchema, 'testEntity');
      const listContract = ops.list().build();
      const readContract = ops.read().build();
      const createContract = ops.create().build();
      const updateContract = ops.update().build();
      const deleteContract = ops.delete().build();

      // Verify all contracts have RouteBuilder metadata
      expect(listContract).toHaveProperty('~orpc');
      expect(readContract).toHaveProperty('~orpc');
      expect(createContract).toHaveProperty('~orpc');
      expect(updateContract).toHaveProperty('~orpc');
      expect(deleteContract).toHaveProperty('~orpc');

      // Verify HTTP methods are correctly set using the actual metadata key
      const listMeta = (listContract as any)['~orpc'];
      expect(listMeta?.meta?.[ROUTE_METHOD_META_KEY]?.method).toBe('GET');

      const createMeta = (createContract as any)['~orpc'];
      expect(createMeta?.meta?.[ROUTE_METHOD_META_KEY]?.method).toBe('POST');

      const updateMeta = (updateContract as any)['~orpc'];
      expect(updateMeta?.meta?.[ROUTE_METHOD_META_KEY]?.method).toBe('PUT');

      const deleteMeta = (deleteContract as any)['~orpc'];
      expect(deleteMeta?.meta?.[ROUTE_METHOD_META_KEY]?.method).toBe('DELETE');
    });

    it('should support input/output builder chaining', () => {
      const ops = standard(testEntitySchema, 'testEntity');
      
      // Test input builder modifications
      const createContract = ops.create()
        .inputBuilder.omit(['id', 'createdAt', 'updatedAt'])
        .build();
      
      expect(createContract).toBeDefined();
      expect(createContract['~orpc']).toBeDefined();

      // Test output builder modifications
      const readContract = ops.read()
        .outputBuilder.nullable()
        .build();
      
      expect(readContract).toBeDefined();
      expect(readContract['~orpc']).toBeDefined();
    });
  });

  describe('Hook Generation from standard() Contracts', () => {
    it('should generate query hooks for GET operations', () => {
      const ops = standard(testEntitySchema, 'testEntity');
      
      // Create mock router with TanStack Query utilities
      const mockRouter = {
        list: {
          ...ops.list().build(),
          queryKey: ['testEntity.list'],
          queryOptions: (opts: any) => ({
            queryKey: ['testEntity.list', opts.input],
            queryFn: () => Promise.resolve([]),
          }),
        },
        read: {
          ...ops.read().build(),
          queryKey: ['testEntity.read'],
          queryOptions: (opts: any) => ({
            queryKey: ['testEntity.read', opts.input],
            queryFn: () => Promise.resolve(null),
          }),
        },
      };

      const queryClient = { invalidateQueries: vi.fn() };
      
      reactQueryMocks.useQuery.mockImplementation((opts: any) => ({
        data: undefined,
        isLoading: false,
        error: null,
      }));

      const hooks = createRouterHooks<typeof mockRouter>(mockRouter, {
        useQueryClient: () => queryClient as any,
      });

      // Verify query hooks were generated
      expect(hooks).toHaveProperty('useList');
      expect(hooks).toHaveProperty('useRead');

      // Verify hooks can be called
      // @ts-expect-error - Testing runtime behavior
      hooks.useList({ limit: 10 });
      expect(reactQueryMocks.useQuery).toHaveBeenCalled();
    });

    it('should generate mutation hooks for non-GET operations', () => {
      const ops = standard(testEntitySchema, 'testEntity');
      
      // Create mock router with TanStack Query utilities
      const mockRouter = {
        create: {
          ...ops.create().build(),
          mutationOptions: (opts: any) => ({
            mutationFn: opts.input,
          }),
          call: (input: any) => Promise.resolve(input),
        },
        update: {
          ...ops.update().build(),
          mutationOptions: (opts: any) => ({
            mutationFn: opts.input,
          }),
          call: (input: any) => Promise.resolve(input),
        },
        delete: {
          ...ops.delete().build(),
          mutationOptions: (opts: any) => ({
            mutationFn: opts.input,
          }),
          call: (input: any) => Promise.resolve({ success: true }),
        },
      };

      const queryClient = { invalidateQueries: vi.fn() };
      
      reactQueryMocks.useMutation.mockImplementation((opts: any) => ({
        mutate: vi.fn(),
        mutateAsync: vi.fn(),
        isPending: false,
        error: null,
      }));

      const hooks = createRouterHooks<typeof mockRouter>(mockRouter, {
        useQueryClient: () => queryClient as any,
      });

      // Verify mutation hooks were generated
      expect(hooks).toHaveProperty('useCreate');
      expect(hooks).toHaveProperty('useUpdate');
      expect(hooks).toHaveProperty('useDelete');

      // Verify hooks can be called
      // @ts-expect-error - Testing runtime behavior
      hooks.useCreate();
      expect(reactQueryMocks.useMutation).toHaveBeenCalled();
    });

    it('should generate all CRUD hooks from standard() operations', () => {
      const ops = standard(testEntitySchema, 'testEntity');
      
      // Create a complete CRUD router
      const mockRouter = {
        list: {
          ...ops.list().build(),
          queryKey: ['testEntity.list'],
          queryOptions: (opts: any) => ({ queryKey: ['testEntity.list'], queryFn: () => [] }),
        },
        read: {
          ...ops.read().build(),
          queryKey: ['testEntity.read'],
          queryOptions: (opts: any) => ({ queryKey: ['testEntity.read'], queryFn: () => null }),
        },
        create: {
          ...ops.create().build(),
          mutationOptions: (opts: any) => ({ mutationFn: opts.input }),
          call: (input: any) => Promise.resolve(input),
        },
        update: {
          ...ops.update().build(),
          mutationOptions: (opts: any) => ({ mutationFn: opts.input }),
          call: (input: any) => Promise.resolve(input),
        },
        delete: {
          ...ops.delete().build(),
          mutationOptions: (opts: any) => ({ mutationFn: opts.input }),
          call: (input: any) => Promise.resolve({ success: true }),
        },
      };

      const queryClient = { invalidateQueries: vi.fn() };
      
      reactQueryMocks.useQuery.mockImplementation(() => ({
        data: undefined,
        isLoading: false,
      }));
      reactQueryMocks.useMutation.mockImplementation(() => ({
        mutate: vi.fn(),
      }));

      const hooks = createRouterHooks<typeof mockRouter>(mockRouter, {
        useQueryClient: () => queryClient as any,
      });

      // Verify all CRUD hooks were generated
      expect(hooks).toHaveProperty('useList');
      expect(hooks).toHaveProperty('useRead');
      expect(hooks).toHaveProperty('useCreate');
      expect(hooks).toHaveProperty('useUpdate');
      expect(hooks).toHaveProperty('useDelete');
    });
  });

  describe('Cache Invalidation with standard() Operations', () => {
    it('should support typed invalidation configuration', () => {
      const ops = standard(testEntitySchema, 'testEntity');
      
      const mockRouter = {
        list: {
          ...ops.list().build(),
          queryKey: ['testEntity.list'],
          queryOptions: (opts: any) => ({ queryKey: ['testEntity.list'] }),
        },
        read: {
          ...ops.read().build(),
          queryKey: ['testEntity.read'],
          queryOptions: (opts: any) => ({ queryKey: ['testEntity.read'] }),
        },
        create: {
          ...ops.create().build(),
          mutationOptions: (opts: any) => ({ mutationFn: opts.input }),
          call: (input: any) => Promise.resolve(input),
        },
        update: {
          ...ops.update().build(),
          mutationOptions: (opts: any) => ({ mutationFn: opts.input }),
          call: (input: any) => Promise.resolve(input),
        },
      };

      // Define typed invalidations
      const invalidations = defineInvalidations<typeof mockRouter>(mockRouter, {
        create: ['list'],
        update: (input) => ({
          read: { id: input.id },
          list: undefined,
        }),
      });

      expect(invalidations).toHaveProperty('create');
      expect(invalidations).toHaveProperty('update');
      expect(Array.isArray(invalidations.create)).toBe(true);
      expect(typeof invalidations.update).toBe('function');
    });

    it('should properly invalidate queries after mutations', () => {
      const ops = standard(testEntitySchema, 'testEntity');
      
      const mockRouter = {
        list: {
          ...ops.list().build(),
          queryKey: ['testEntity.list'],
          queryOptions: (opts: any) => ({ queryKey: ['testEntity.list'] }),
        },
        create: {
          ...ops.create().build(),
          mutationOptions: (opts: any) => opts,
          call: (input: any) => Promise.resolve(input),
        },
      };

      const invalidateQueries = vi.fn();
      const queryClient = { invalidateQueries };

      const invalidations = defineInvalidations<typeof mockRouter>(mockRouter, {
        create: ['list'],
      });

      reactQueryMocks.useMutation.mockImplementation((opts: any) => ({
        mutate: vi.fn(),
        options: opts,
      }));

      const hooks = createRouterHooks<typeof mockRouter>(mockRouter, {
        invalidations,
        useQueryClient: () => queryClient as any,
      });

      // @ts-expect-error - Testing runtime behavior
      hooks.useCreate();

      expect(reactQueryMocks.useMutation).toHaveBeenCalled();
      
      // Trigger onSuccess manually
      const mutationOpts = reactQueryMocks.useMutation.mock.calls[0]?.[0];
      const testData = { id: '1', name: 'Test' };
      mutationOpts?.onSuccess?.(testData, testData, undefined);

      // Verify invalidation was called
      expect(invalidateQueries).toHaveBeenCalledWith({
        queryKey: ['testEntity.list'],
      });
    });
  });

  describe('Type Safety', () => {
    it('should maintain type safety through the entire chain', () => {
      const ops = standard(testEntitySchema, 'testEntity');
      
      // Create contracts
      const listContract = ops.list().build();
      const createContract = ops.create()
        .inputBuilder.omit(['id', 'createdAt', 'updatedAt'])
        .build();

      // Verify contracts have proper structure
      expect(listContract).toBeDefined();
      expect(createContract).toBeDefined();

      // Type assertions to verify TypeScript inference
      type ListContract = typeof listContract;
      type CreateContract = typeof createContract;

      // These should compile without errors
      const _listHasOrpc: ListContract extends { '~orpc': any } ? true : false = true;
      const _createHasOrpc: CreateContract extends { '~orpc': any } ? true : false = true;

      expect(_listHasOrpc).toBe(true);
      expect(_createHasOrpc).toBe(true);
    });

    it('should properly type hook return values', () => {
      const ops = standard(testEntitySchema, 'testEntity');
      
      const mockRouter = {
        list: {
          ...ops.list().build(),
          queryKey: ['testEntity.list'],
          queryOptions: (opts: any) => ({
            queryKey: ['testEntity.list'],
            queryFn: () => Promise.resolve([]),
          }),
        },
        create: {
          ...ops.create().build(),
          mutationOptions: (opts: any) => ({
            mutationFn: () => Promise.resolve({}),
          }),
          call: (input: any) => Promise.resolve(input),
        },
      };

      const queryClient = { invalidateQueries: vi.fn() };

      reactQueryMocks.useQuery.mockReturnValue({
        data: [],
        isLoading: false,
        error: null,
      });

      reactQueryMocks.useMutation.mockReturnValue({
        mutate: vi.fn(),
        isPending: false,
        error: null,
      });

      const hooks = createRouterHooks<typeof mockRouter>(mockRouter, {
        useQueryClient: () => queryClient as any,
      });

      // Verify hooks have proper return types
      // @ts-expect-error - Testing runtime behavior
      const listResult = hooks.useList();
      // @ts-expect-error - Testing runtime behavior
      const createResult = hooks.useCreate();

      expect(listResult).toHaveProperty('data');
      expect(listResult).toHaveProperty('isLoading');
      expect(createResult).toHaveProperty('mutate');
      expect(createResult).toHaveProperty('isPending');
    });
  });

  describe('Advanced Features', () => {
    it('should support count operation', () => {
      const ops = standard(testEntitySchema, 'testEntity');
      const countContract = ops.count().build();

      expect(countContract).toBeDefined();
      expect(countContract['~orpc']).toBeDefined();
      
      const countMeta = (countContract as any)['~orpc'];
      expect(countMeta?.meta?.[ROUTE_METHOD_META_KEY]?.method).toBe('GET');
    });

    it('should support check operation', () => {
      const ops = standard(testEntitySchema, 'testEntity');
      const checkContract = ops.check('email').build();

      expect(checkContract).toBeDefined();
      expect(checkContract['~orpc']).toBeDefined();
      
      const checkMeta = (checkContract as any)['~orpc'];
      // check() uses GET method for idempotent read operations
      expect(checkMeta?.meta?.[ROUTE_METHOD_META_KEY]?.method).toBe('GET');
    });

    it('should support patch operation', () => {
      const ops = standard(testEntitySchema, 'testEntity');
      const patchContract = ops.patch().build();

      expect(patchContract).toBeDefined();
      expect(patchContract['~orpc']).toBeDefined();
      
      const patchMeta = (patchContract as any)['~orpc'];
      expect(patchMeta?.meta?.[ROUTE_METHOD_META_KEY]?.method).toBe('PATCH');
    });
  });

  describe('Real-world Usage Pattern', () => {
    it('should work exactly like the user contracts in production', () => {
      // Simulate real user schema
      const userSchema = z.object({
        id: z.string().uuid(),
        name: z.string(),
        email: z.string().email(),
        emailVerified: z.boolean(),
        image: z.string().nullable(),
        createdAt: z.date(),
        updatedAt: z.date(),
      });
      
      // Type test: verify schema inference
      expectTypeOf<z.infer<typeof userSchema>>().toMatchTypeOf<{
        id: string;
        name: string;
        email: string;
        emailVerified: boolean;
        image: string | null;
        createdAt: Date;
        updatedAt: Date;
      }>();

      // Create operations like in production
      const userOps = standard(userSchema, 'user');

      // Create contracts exactly as done in packages/contracts/api/modules/user/
      const listContract = userOps.list().build();
      const findByIdContract = userOps.read().outputBuilder.nullable().build();
      const createContract = userOps.create()
        .inputBuilder.pick(['name', 'email', 'image'])
        .build();
      const updateContract = userOps.update().build();
      const deleteContract = userOps.delete().build();
      const countContract = userOps.count().build();
      const checkEmailContract = userOps.check('email').build();

      // Verify all contracts are valid
      expect(listContract['~orpc']).toBeDefined();
      expect(findByIdContract['~orpc']).toBeDefined();
      expect(createContract['~orpc']).toBeDefined();
      expect(updateContract['~orpc']).toBeDefined();
      expect(deleteContract['~orpc']).toBeDefined();
      expect(countContract['~orpc']).toBeDefined();
      expect(checkEmailContract['~orpc']).toBeDefined();

      // Create mock router (simulating TanStack Query utils)
      const mockUserRouter = {
        list: {
          ...listContract,
          queryKey: ['user.list'],
          queryOptions: () => ({ queryKey: ['user.list'] }),
        },
        findById: {
          ...findByIdContract,
          queryKey: ['user.findById'],
          queryOptions: () => ({ queryKey: ['user.findById'] }),
        },
        create: {
          ...createContract,
          mutationOptions: (opts: any) => ({ mutationFn: opts.input }),
          call: (input: any) => Promise.resolve(input),
        },
        update: {
          ...updateContract,
          mutationOptions: (opts: any) => ({ mutationFn: opts.input }),
          call: (input: any) => Promise.resolve(input),
        },
        delete: {
          ...deleteContract,
          mutationOptions: (opts: any) => ({ mutationFn: opts.input }),
          call: (__input: any) => Promise.resolve({ success: true }),
        },
        count: {
          ...countContract,
          queryKey: ['user.count'],
          queryOptions: () => ({ queryKey: ['user.count'] }),
        },
        checkEmail: {
          ...checkEmailContract,
          queryKey: ['user.checkEmail'],
          queryOptions: () => ({ queryKey: ['user.checkEmail'] }),
        },
      };

      const queryClient = { invalidateQueries: vi.fn() };

      reactQueryMocks.useQuery.mockImplementation(() => ({
        data: undefined,
        isLoading: false,
      }));
      reactQueryMocks.useMutation.mockImplementation(() => ({
        mutate: vi.fn(),
      }));

      // Generate hooks exactly like in production
      const userHooks = createRouterHooks<typeof mockUserRouter>(mockUserRouter, {
        invalidations: defineInvalidations<typeof mockUserRouter>(mockUserRouter, {
          create: ['list', 'count'],
          delete: ['list', 'count', 'findById'],
        }),
        useQueryClient: () => queryClient as any,
        debug: true, // Enable debug logging
      });
      
      // Type test: verify hooks are properly typed
      expectTypeOf(userHooks).toHaveProperty('useList');
      expectTypeOf(userHooks).toHaveProperty('useFindById');
      expectTypeOf(userHooks).toHaveProperty('useCreate');
      expectTypeOf(userHooks).toHaveProperty('useUpdate');
      expectTypeOf(userHooks).toHaveProperty('useDelete');
      expectTypeOf(userHooks).toHaveProperty('useCount');
      expectTypeOf(userHooks).toHaveProperty('useCheckEmail');

      // Log what hooks were actually generated
      console.log('Generated hooks:', Object.keys(userHooks));

      // Verify all expected hooks were generated
      expect(userHooks).toHaveProperty('useList');
      expect(userHooks).toHaveProperty('useFindById');
      expect(userHooks).toHaveProperty('useCreate');
      expect(userHooks).toHaveProperty('useUpdate');
      expect(userHooks).toHaveProperty('useDelete');
      expect(userHooks).toHaveProperty('useCount');
      expect(userHooks).toHaveProperty('useCheckEmail');

      // Verify hooks can be used
      userHooks.useList();
      expect(reactQueryMocks.useQuery).toHaveBeenCalled();

      userHooks.useCreate();
      expect(reactQueryMocks.useMutation).toHaveBeenCalled();
    });
  });
});
