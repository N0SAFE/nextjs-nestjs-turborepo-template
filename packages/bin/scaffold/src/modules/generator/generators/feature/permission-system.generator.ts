/**
 * Permission System Generator
 *
 * Scaffolds RBAC/ABAC permission systems using PermissionBuilder pattern.
 * Creates the permission infrastructure including:
 * - Resource and action definitions
 * - Role definitions with permissions
 * - Type-safe permission schemas
 * - Integration with better-auth admin plugin
 */
import { Injectable } from "@nestjs/common";
import { BaseGenerator } from "../../base/base.generator";
import type {
  GeneratorContext,
  FileSpec,
  DependencySpec,
} from "../../../../types/generator.types";

@Injectable()
export class PermissionSystemGenerator extends BaseGenerator {
  protected override metadata = {
    pluginId: "permission-system",
    priority: 36, // After better-auth-bearer (35)
    version: "1.0.0",
    description: "RBAC/ABAC permission system with PermissionBuilder pattern",
    contributesTo: [
      "packages/utils/auth/src/permissions/**",
    ],
    dependsOn: ["better-auth"],
  };

  protected override getFiles(context: GeneratorContext): FileSpec[] {
    const files: FileSpec[] = [];

    // System builder files
    files.push(
      this.file(
        "packages/utils/auth/src/permissions/system/index.ts",
        this.getSystemIndexContent(),
        { mergeStrategy: "replace", priority: 36 },
      ),
    );

    files.push(
      this.file(
        "packages/utils/auth/src/permissions/system/types.ts",
        this.getTypesContent(),
        { mergeStrategy: "replace", priority: 36 },
      ),
    );

    files.push(
      this.file(
        "packages/utils/auth/src/permissions/system/builder/shared/base-config.ts",
        this.getBaseConfigContent(),
        { mergeStrategy: "replace", priority: 36 },
      ),
    );

    files.push(
      this.file(
        "packages/utils/auth/src/permissions/system/builder/builder.ts",
        this.getBuilderContent(),
        { mergeStrategy: "replace", priority: 36 },
      ),
    );

    files.push(
      this.file(
        "packages/utils/auth/src/permissions/system/builder/schemas.ts",
        this.getSchemasContent(),
        { mergeStrategy: "replace", priority: 36 },
      ),
    );

    files.push(
      this.file(
        "packages/utils/auth/src/permissions/system/builder/statements/statements-config.ts",
        this.getStatementsConfigContent(),
        { mergeStrategy: "replace", priority: 36 },
      ),
    );

    files.push(
      this.file(
        "packages/utils/auth/src/permissions/system/builder/statements/statement-config.ts",
        this.getStatementConfigContent(),
        { mergeStrategy: "replace", priority: 36 },
      ),
    );

    files.push(
      this.file(
        "packages/utils/auth/src/permissions/system/builder/roles/roles-config.ts",
        this.getRolesConfigContent(),
        { mergeStrategy: "replace", priority: 36 },
      ),
    );

    files.push(
      this.file(
        "packages/utils/auth/src/permissions/system/builder/roles/role-config.ts",
        this.getRoleConfigContent(),
        { mergeStrategy: "replace", priority: 36 },
      ),
    );

    // Main permissions configuration
    files.push(
      this.file(
        "packages/utils/auth/src/permissions/config.ts",
        this.getPermissionsConfigContent(),
        { mergeStrategy: "replace", priority: 36 },
      ),
    );

    files.push(
      this.file(
        "packages/utils/auth/src/permissions/index.ts",
        this.getPermissionsIndexContent(),
        { mergeStrategy: "replace", priority: 36 },
      ),
    );

    return files;
  }

  protected override getDependencies(_context: GeneratorContext): DependencySpec[] {
    // Dependencies come from better-auth and zod generators
    return [];
  }

  private getSystemIndexContent(): string {
    return `// Permission System Exports
// Generated by scaffold CLI

export { PermissionBuilder, ResourceBuilder, RoleBuilder, createPermissionBuilder, createPermissionBuilderWithDefaults } from "./builder/builder";
export type { RolesAsRoleObjects } from "./builder/builder";

export { BaseConfig } from "./builder/shared/base-config";
export type { BaseConfigContract } from "./builder/shared/base-config";

export { StatementsConfig } from "./builder/statements/statements-config";
export { StatementConfig } from "./builder/statements/statement-config";
export type { StatementConfigCollection } from "./builder/statements/statements-config";

export { RolesConfig } from "./builder/roles/roles-config";
export { RoleConfig } from "./builder/roles/role-config";
export type { RoleConfigCollection } from "./builder/roles/roles-config";

export type {
  Permission,
  Resource,
  ResourceActions,
  RoleName,
  RolePermissions,
  PermissionCheck,
  AccessControlConfig,
  PermissionChecker,
  RolePermissionChecker,
} from "./types";
`;
  }

  private getTypesContent(): string {
    return `// Permission System Types
// Generated by scaffold CLI

/**
 * A permission is a combination of resource and action
 */
export type Permission<
  TResource extends string = string,
  TAction extends string = string
> = \`\${TResource}:\${TAction}\`;

/**
 * Resource definition with associated actions
 */
export type Resource<
  TName extends string = string,
  TActions extends readonly string[] = readonly string[]
> = {
  name: TName;
  actions: TActions;
};

/**
 * Map of resources to their allowed actions
 */
export type ResourceActions<
  TResources extends Record<string, readonly string[]> = Record<string, readonly string[]>
> = TResources;

/**
 * Role name type
 */
export type RoleName<TRoles extends string = string> = TRoles;

/**
 * Role permissions definition
 */
export type RolePermissions<
  TStatement extends Record<string, readonly string[]> = Record<string, readonly string[]>
> = {
  [K in keyof TStatement]?: readonly TStatement[K][number][];
};

/**
 * Permission check parameters
 */
export interface PermissionCheck<
  TResource extends string = string,
  TAction extends string = string,
  TRole extends string = string
> {
  resource: TResource;
  action: TAction;
  role?: TRole;
}

/**
 * Access control configuration
 */
export interface AccessControlConfig<
  TStatement extends Record<string, readonly string[]> = Record<string, readonly string[]>,
  TRoles extends Record<string, Record<string, readonly string[]>> = Record<string, Record<string, readonly string[]>>
> {
  statement: TStatement;
  roles: TRoles;
}

/**
 * Permission checker function type
 */
export type PermissionChecker<
  TStatement extends Record<string, readonly string[]>
> = <TResource extends keyof TStatement>(
  resource: TResource,
  action: TStatement[TResource][number]
) => boolean;

/**
 * Role-based permission checker
 */
export type RolePermissionChecker<
  TStatement extends Record<string, readonly string[]>,
  TRoles extends Record<string, Record<string, readonly string[]>>
> = <TRole extends keyof TRoles>(
  role: TRole,
  resource: keyof TStatement,
  action: string
) => boolean;
`;
  }

  private getBaseConfigContent(): string {
    return `// Base Configuration Class
// Generated by scaffold CLI

/**
 * Base configuration contract for permission builders
 */
export interface BaseConfigContract {
  statementsConfig: unknown;
  rolesConfig: unknown;
  statement: Record<string, readonly string[]>;
  ac: unknown;
  roles: unknown;
}

/**
 * Base class for permission configuration
 * Provides common functionality for permission builders
 */
export class BaseConfig<TConfig extends BaseConfigContract> {
  protected _config: TConfig;

  constructor(config: TConfig) {
    this._config = config;
  }

  /**
   * Get the full configuration object
   */
  getConfig(): TConfig {
    return this._config;
  }
}
`;
  }

  private getBuilderContent(): string {
    return `import type { Role, Statements } from "better-auth/plugins/access";
import { createAccessControl } from "better-auth/plugins/access";
import { BaseConfig } from "./shared/base-config";
import { StatementsConfig } from "./statements/statements-config";
import { RolesConfig } from "./roles/roles-config";
import { createSchemas } from "./schemas";

// Generated by scaffold CLI - Permission Builder

/**
 * Extract all statement types from TDefaultRoles and merge them
 */
type ExtractStatementUnion<TDefaultRoles extends Record<string, { statements: Record<string, readonly string[]> }>> = 
  TDefaultRoles[keyof TDefaultRoles]['statements'];

/**
 * Get all resource names from the statement union
 */
type AllResourceNames<TStatementUnion extends Record<string, readonly string[]>> = keyof TStatementUnion;

/**
 * For a given resource name, extract the actions from the statement that has it
 */
type ActionsForResource<
  TStatementUnion extends Record<string, readonly string[]>,
  Resource extends string
> = TStatementUnion extends Record<Resource, infer Actions>
  ? Actions extends readonly string[]
    ? Actions
    : never
  : never;

/**
 * Type helper to merge all statements from default roles into a single object type
 */
type MergeDefaultStatements<TDefaultRoles extends Record<string, { statements: Record<string, readonly string[]> }>> = {
  [Resource in AllResourceNames<ExtractStatementUnion<TDefaultRoles>> & string]: 
    ActionsForResource<ExtractStatementUnion<TDefaultRoles>, Resource>
};

/**
 * Mapped type that converts a roles permissions record into Role objects
 */
export type RolesAsRoleObjects<TRoles extends Record<string, Record<string, readonly string[]>>> = {
  [K in keyof TRoles]: Role<TRoles[K]>;
};

/**
 * Resource builder for adding actions to a resource
 */
export class ResourceBuilder<
  TStatement extends Record<string, readonly string[]>,
  TResource extends string,
  TRoles extends Record<string, Record<string, readonly string[]>> = Record<string, never>
> {
  constructor(
    private builder: PermissionBuilder<TStatement, TRoles>,
    private resourceName: TResource
  ) {}

  /**
   * Define actions for the current resource
   */
  actions<const TActions extends readonly string[]>(
    actions: TActions
  ): PermissionBuilder<TStatement & Record<TResource, TActions>, TRoles> {
    this.builder._statement[this.resourceName] = actions;
    return this.builder as unknown as PermissionBuilder<
      TStatement & Record<TResource, TActions>,
      TRoles
    >;
  }
}

/**
 * Role builder for defining role permissions
 */
export class RoleBuilder<
  TStatement extends Record<string, readonly string[]>,
  TRoles extends Record<string, Record<string, readonly string[]>>,
  TRoleName extends string = string
> {
  constructor(
    private builder: PermissionBuilder<TStatement, TRoles>,
    private roleName: TRoleName,
    private ac: ReturnType<typeof createAccessControl<TStatement>>
  ) {}

  /**
   * Define permissions for the current role
   */
  permissions<
    const TPermissions extends {
      [K in keyof TStatement]?: readonly (TStatement[K][number])[];
    }
  >(
    permissions: TPermissions
  ): PermissionBuilder<TStatement, TRoles & Record<typeof this.roleName, TPermissions>> {
    // @ts-expect-error - Type manipulation for builder pattern
    this.builder._roles[this.roleName] = this.ac.newRole(permissions);
    return this.builder as unknown as PermissionBuilder<
      TStatement,
      TRoles & Record<typeof this.roleName, TPermissions>
    >;
  }

  /**
   * Give this role all permissions from the statement
   */
  allPermissions(): PermissionBuilder<TStatement, TRoles & Record<typeof this.roleName, TStatement>> {
    // @ts-expect-error - Type manipulation for builder pattern
    this.builder._roles[this.roleName] = this.ac.newRole(this.builder._statement);
    return this.builder as unknown as PermissionBuilder<
      TStatement,
      TRoles & Record<typeof this.roleName, TStatement>
    >;
  }
}

/**
 * Main Permission Builder class
 * 
 * Provides a fluent API for building permission statements and roles
 * with full type safety and autocomplete support.
 * 
 * @example
 * \\\`\\\`\\\`typescript
 * const builder = new PermissionBuilder()
 *   .resource('project')
 *     .actions(['create', 'read', 'update', 'delete', 'share'])
 *   .resource('organization')
 *     .actions(['create', 'read', 'update', 'delete', 'manage-members'])
 *   .build();
 * 
 * const { statement, ac, roles } = builder;
 * \\\`\\\`\\\`
 */
export class PermissionBuilder<
  TStatement extends Record<string, readonly string[]>,
  TRoles extends Record<string, Record<string, readonly string[]>>
> extends BaseConfig<{
  statementsConfig: StatementsConfig<TStatement>;
  rolesConfig: RolesConfig<TRoles>;
  statement: TStatement & Statements;
  ac: ReturnType<typeof createAccessControl<TStatement>>;
  roles: RolesAsRoleObjects<TRoles>;
}> {
  /** @internal */
  _statement: Record<string, readonly string[]> = {};
  
  /** @internal */
  _roles: Record<string, unknown> = {};
  
  private _ac?: ReturnType<typeof createAccessControl<TStatement>>;
  private _statementsConfig?: StatementsConfig<TStatement>;
  private _rolesConfig?: RolesConfig<TRoles>;

  constructor() {
    super({} as never);
  }

  /**
   * Start building with default Better Auth admin roles
   */
  static withDefaults<
    TDefaultRoles extends Record<string, { statements: Record<string, readonly string[]> }>,
    TStatement extends Record<string, readonly string[]> = MergeDefaultStatements<TDefaultRoles>,
    TRoles extends Record<string, Record<string, readonly string[]>> = {
      [K in keyof TDefaultRoles]: TDefaultRoles[K]['statements']
    }
  >(
    defaultRoles: TDefaultRoles
  ): PermissionBuilder<TStatement, TRoles> {
    const builder = new PermissionBuilder<TStatement, TRoles>();
    
    const allStatements: Record<string, readonly string[]> = {};
    for (const [, role] of Object.entries(defaultRoles)) {
      Object.assign(allStatements, role.statements);
    }
    builder._statement = allStatements;
    
    const rolesStructure: Record<string, Record<string, readonly string[]>> = {};
    for (const [roleName, role] of Object.entries(defaultRoles)) {
      rolesStructure[roleName] = role.statements;
    }
    Object.assign(builder._roles, rolesStructure);
    
    return builder;
  }

  /**
   * Add a new resource to the permission statement
   */
  resource<TResource extends string>(
    name: TResource
  ): ResourceBuilder<TStatement, TResource, TRoles> {
    return new ResourceBuilder(this, name);
  }

  /**
   * Add multiple resources at once with a simple actions helper
   */
  resources<const TResources extends Record<string, readonly string[]>>(
    resourcesFactory: (helpers: {
      actions: <const TActions extends readonly string[]>(actions: TActions) => TActions;
    }) => TResources
  ): PermissionBuilder<TStatement & TResources, TRoles> {
    const helpers = {
      actions: <const TActions extends readonly string[]>(actions: TActions): TActions => actions
    };
    
    const resourceDefinitions = resourcesFactory(helpers);
    
    for (const [resourceName, actions] of Object.entries(resourceDefinitions)) {
      new ResourceBuilder(this, resourceName).actions(actions);
    }
    
    return this as unknown as PermissionBuilder<TStatement & TResources, TRoles>;
  }

  /**
   * Start defining a role
   */
  role<const TRole extends string>(
    name: TRole
  ): RoleBuilder<TStatement, TRoles, TRole> {
    this._ac ??= createAccessControl(this._statement as TStatement);
    return new RoleBuilder<TStatement, TRoles, TRole>(this, name, this._ac);
  }

  /**
   * Add multiple roles at once with a simple permissions helper
   */
  roles<const TNewRoles extends Record<string, Record<string, readonly string[]>>>(
    rolesFactory: (helpers: {
      statement: TStatement;
      permissions: <
        const TPermissions extends {
          [K in keyof TStatement]?: readonly (TStatement[K][number])[];
        }
      >(permissions: TPermissions) => TPermissions;
    }) => TNewRoles
  ): PermissionBuilder<TStatement, TRoles & TNewRoles> {
    const helpers = {
      statement: this._statement as TStatement,
      permissions: <
        const TPermissions extends {
          [K in keyof TStatement]?: readonly (TStatement[K][number])[];
        }
      >(permissions: TPermissions): TPermissions => permissions
    };
    
    const roleDefinitions = rolesFactory(helpers);
    
    this._ac ??= createAccessControl(this._statement as TStatement);
    
    for (const [roleName, perms] of Object.entries(roleDefinitions)) {
      new RoleBuilder(this, roleName, this._ac).permissions(perms);
    }
    
    return this as unknown as PermissionBuilder<TStatement, TRoles & TNewRoles>;
  }

  /**
   * Build and return the final statement, access control instance, roles, and schemas
   */
  build() {
    this._ac = createAccessControl(this._statement as TStatement);
    this._statementsConfig = new StatementsConfig(this._statement as TStatement);
    this._rolesConfig = new RolesConfig(this._roles as TRoles);
    const schemas = createSchemas(this);

    return {
      statementsConfig: this._statementsConfig,
      rolesConfig: this._rolesConfig,
      statement: this._statement as TStatement,
      ac: this._ac,
      roles: this._roles as RolesAsRoleObjects<TRoles>,
      schemas,
    };
  }

  getStatementsConfig(): StatementsConfig<TStatement> {
    return this._statementsConfig ??= new StatementsConfig(this._statement as TStatement);
  }

  getRolesConfig(): RolesConfig<TRoles> {
    return this._rolesConfig ??= new RolesConfig(this._roles as TRoles);
  }

  getStatement(): TStatement {
    return this._statement as TStatement;
  }

  getAc(): ReturnType<typeof createAccessControl<TStatement>> {
    return this._ac ??= createAccessControl(this._statement as TStatement);
  }

  getRoles(): RolesAsRoleObjects<TRoles> {
    return this._roles as RolesAsRoleObjects<TRoles>;
  }

  createPermission<T extends Record<string, readonly string[]>>(
    permissions: 
      | T 
      | ((
          config: { 
            statementsConfig: StatementsConfig<TStatement>;
            rolesConfig: RolesConfig<TRoles>;
            ac: ReturnType<typeof createAccessControl<TStatement>>;
          },
          builder: this
        ) => T)
  ): T {
    if (typeof permissions === 'function') {
      const ac = this.getAc();
      const statementsConfig = this.getStatementsConfig();
      const rolesConfig = this.getRolesConfig();
      
      return permissions({ statementsConfig, rolesConfig, ac }, this);
    }
    return permissions;
  }
  
  get statement(): TStatement {
    return this._statement as TStatement;
  }
}

/**
 * Helper function to create a new PermissionBuilder
 */
export function createPermissionBuilder() {
  return new PermissionBuilder();
}

/**
 * Helper function to create a PermissionBuilder with Better Auth defaults
 */
export function createPermissionBuilderWithDefaults<
  TDefaultRoles extends Record<string, { statements: Record<string, readonly string[]> }>
>(defaultRoles: TDefaultRoles) {
  return PermissionBuilder.withDefaults(defaultRoles);
}
`;
  }

  private getSchemasContent(): string {
    return `import { z } from "zod";
import type { PermissionBuilder } from "./builder";

// Generated by scaffold CLI - Permission Schemas

/**
 * Create Zod schemas for permission validation
 */
export function createSchemas<
  TStatement extends Record<string, readonly string[]>,
  TRoles extends Record<string, Record<string, readonly string[]>>
>(builder: PermissionBuilder<TStatement, TRoles>) {
  const statement = builder.getStatement();
  const roles = builder.getRoles();

  // Create resource enum schema
  const resourceKeys = Object.keys(statement) as [string, ...string[]];
  const resourceSchema = z.enum(resourceKeys);

  // Create role enum schema
  const roleKeys = Object.keys(roles) as [string, ...string[]];
  const roleSchema = z.enum(roleKeys);

  // Create action schemas per resource
  const actionSchemas: Record<string, z.ZodEnum<[string, ...string[]]>> = {};
  for (const [resource, actions] of Object.entries(statement)) {
    const actionArray = actions as unknown as [string, ...string[]];
    actionSchemas[resource] = z.enum(actionArray);
  }

  // Create permission check schema
  const permissionCheckSchema = z.object({
    resource: resourceSchema,
    action: z.string(),
    role: roleSchema.optional(),
  });

  return {
    resource: resourceSchema,
    role: roleSchema,
    actions: actionSchemas,
    permissionCheck: permissionCheckSchema,
  };
}
`;
  }

  private getStatementsConfigContent(): string {
    return `import { StatementConfig } from "./statement-config";

// Generated by scaffold CLI - Statements Configuration

/**
 * Collection of statement configs
 */
export type StatementConfigCollection<TStatement extends Record<string, readonly string[]>> = {
  [K in keyof TStatement]: StatementConfig<TStatement[K]>;
};

/**
 * Statements configuration helper
 * Provides typed access to resource statements
 */
export class StatementsConfig<TStatement extends Record<string, readonly string[]>> {
  private configs: StatementConfigCollection<TStatement>;

  constructor(statement: TStatement) {
    this.configs = {} as StatementConfigCollection<TStatement>;
    
    for (const [resource, actions] of Object.entries(statement)) {
      (this.configs as Record<string, StatementConfig<readonly string[]>>)[resource] = 
        new StatementConfig(actions);
    }
  }

  /**
   * Get the config for a specific resource
   */
  get<K extends keyof TStatement>(resource: K): StatementConfig<TStatement[K]> {
    return this.configs[resource];
  }

  /**
   * Get all resource names
   */
  getResourceNames(): (keyof TStatement)[] {
    return Object.keys(this.configs) as (keyof TStatement)[];
  }

  /**
   * Get all configs
   */
  getAll(): StatementConfigCollection<TStatement> {
    return this.configs;
  }
}
`;
  }

  private getStatementConfigContent(): string {
    return `// Generated by scaffold CLI - Statement Configuration

/**
 * Configuration helper for a single statement (resource with actions)
 */
export class StatementConfig<TActions extends readonly string[]> {
  constructor(private actions: TActions) {}

  /**
   * Get all actions for this resource
   */
  getActions(): TActions {
    return this.actions;
  }

  /**
   * Pick specific actions
   */
  pick<const TSelected extends readonly TActions[number][]>(
    selected: TSelected
  ): StatementConfigBuilder<TSelected> {
    return new StatementConfigBuilder(selected);
  }

  /**
   * Exclude specific actions
   */
  omit<const TOmitted extends readonly TActions[number][]>(
    omitted: TOmitted
  ): StatementConfigBuilder<readonly Exclude<TActions[number], TOmitted[number]>[]> {
    const filtered = this.actions.filter(
      (action) => !omitted.includes(action as TOmitted[number])
    );
    return new StatementConfigBuilder(filtered as readonly Exclude<TActions[number], TOmitted[number]>[]);
  }

  /**
   * Get read-only actions (typically 'read', 'list')
   */
  readOnly(): StatementConfigBuilder<readonly ('read' | 'list')[]> {
    const readActions = this.actions.filter(
      (action) => action === 'read' || action === 'list'
    ) as unknown as readonly ('read' | 'list')[];
    return new StatementConfigBuilder(readActions);
  }

  /**
   * Get all actions as a builder
   */
  all(): StatementConfigBuilder<TActions> {
    return new StatementConfigBuilder(this.actions);
  }
}

/**
 * Builder for statement configurations
 */
export class StatementConfigBuilder<TActions extends readonly string[]> {
  constructor(private actions: TActions) {}

  /**
   * Build and return the actions array
   */
  build(): TActions {
    return this.actions;
  }
}
`;
  }

  private getRolesConfigContent(): string {
    return `import { RoleConfig } from "./role-config";

// Generated by scaffold CLI - Roles Configuration

/**
 * Collection of role configs
 */
export type RoleConfigCollection<TRoles extends Record<string, Record<string, readonly string[]>>> = {
  [K in keyof TRoles]: RoleConfig<TRoles[K]>;
};

/**
 * Roles configuration helper
 * Provides typed access to role permissions
 */
export class RolesConfig<TRoles extends Record<string, Record<string, readonly string[]>>> {
  private configs: RoleConfigCollection<TRoles>;

  constructor(roles: TRoles) {
    this.configs = {} as RoleConfigCollection<TRoles>;
    
    for (const [roleName, permissions] of Object.entries(roles)) {
      (this.configs as Record<string, RoleConfig<Record<string, readonly string[]>>>)[roleName] = 
        new RoleConfig(permissions as Record<string, readonly string[]>);
    }
  }

  /**
   * Get the config for a specific role
   */
  get<K extends keyof TRoles>(role: K): RoleConfig<TRoles[K]> {
    return this.configs[role];
  }

  /**
   * Get all role names
   */
  getRoleNames(): (keyof TRoles)[] {
    return Object.keys(this.configs) as (keyof TRoles)[];
  }

  /**
   * Get all configs
   */
  getAll(): RoleConfigCollection<TRoles> {
    return this.configs;
  }
}
`;
  }

  private getRoleConfigContent(): string {
    return `// Generated by scaffold CLI - Role Configuration

/**
 * Configuration helper for a single role
 */
export class RoleConfig<TPermissions extends Record<string, readonly string[]>> {
  constructor(private permissions: TPermissions) {}

  /**
   * Get all permissions for this role
   */
  getPermissions(): TPermissions {
    return this.permissions;
  }

  /**
   * Check if role has permission for resource and action
   */
  hasPermission<K extends keyof TPermissions>(
    resource: K,
    action: TPermissions[K][number]
  ): boolean {
    const resourcePermissions = this.permissions[resource];
    if (!resourcePermissions) return false;
    return resourcePermissions.includes(action);
  }

  /**
   * Get actions for a specific resource
   */
  getActionsFor<K extends keyof TPermissions>(resource: K): TPermissions[K] {
    return this.permissions[resource];
  }

  /**
   * Get all resources this role has access to
   */
  getResources(): (keyof TPermissions)[] {
    return Object.keys(this.permissions) as (keyof TPermissions)[];
  }
}
`;
  }

  private getPermissionsConfigContent(): string {
    return `import { defaultRoles } from "better-auth/plugins/admin";
import { PermissionBuilder } from "./system";

// Generated by scaffold CLI - Permissions Configuration

/**
 * Define your application's permission structure
 * 
 * This configuration uses the PermissionBuilder to create a type-safe
 * permission system that integrates with Better Auth's admin plugin.
 * 
 * @example
 * - Start with defaultRoles from better-auth admin plugin
 * - Add your own resources and actions
 * - Define custom roles with specific permissions
 */

// Initialize with Better Auth's default admin roles
const permissionConfig = PermissionBuilder.withDefaults(defaultRoles)
  // Add your custom resources and their actions
  .resources(({ actions }) => ({
    // Example: Project resource
    project: actions(["list", "read", "create", "update", "delete", "share"]),
    
    // Example: Organization resource
    organization: actions(["list", "read", "create", "update", "delete", "manage-members"]),
    
    // Example: Billing resource
    billing: actions(["read", "update", "manage-subscriptions"]),
    
    // Add more resources as needed...
  }))
  // Define custom roles with their permissions
  .roles(({ permissions }) => ({
    // Example: Project manager role
    projectManager: permissions({
      project: ["list", "read", "create", "update", "share"],
      organization: ["read"],
    }),
    
    // Example: Billing admin role
    billingAdmin: permissions({
      billing: ["read", "update", "manage-subscriptions"],
      organization: ["read"],
    }),
    
    // Example: Viewer role
    viewer: permissions({
      project: ["list", "read"],
      organization: ["read"],
      billing: ["read"],
    }),
    
    // Add more roles as needed...
  }))
  .build();

// Export everything for use throughout the application
export const { statement, ac, roles, schemas, statementsConfig, rolesConfig } = permissionConfig;

/**
 * Type exports for use in other parts of the application
 */
export type Statement = typeof statement;
export type Roles = typeof roles;
export type RoleName = keyof Roles;
export type ResourceName = keyof Statement;
`;
  }

  private getPermissionsIndexContent(): string {
    return `// Permissions Module Exports
// Generated by scaffold CLI

// Export permission configuration
export {
  statement,
  ac,
  roles,
  schemas,
  statementsConfig,
  rolesConfig,
} from "./config";

export type {
  Statement,
  Roles,
  RoleName,
  ResourceName,
} from "./config";

// Export system builders for custom permission configurations
export {
  PermissionBuilder,
  ResourceBuilder,
  RoleBuilder,
  createPermissionBuilder,
  createPermissionBuilderWithDefaults,
  BaseConfig,
  StatementsConfig,
  StatementConfig,
  RolesConfig,
  RoleConfig,
} from "./system";

export type {
  RolesAsRoleObjects,
  BaseConfigContract,
  StatementConfigCollection,
  RoleConfigCollection,
  Permission,
  Resource,
  ResourceActions,
  RolePermissions,
  PermissionCheck,
  AccessControlConfig,
  PermissionChecker,
  RolePermissionChecker,
} from "./system";
`;
  }
}
