#!/usr/bin/env bun

import { existsSync } from 'fs';
import { resolve, relative, dirname, join, basename } from 'path';
import { extractLinks, analyzeLinksBreathFirst } from './link-utils';

interface Options {
  start: string;
  depth?: number;
  help?: boolean;
}

interface FileNode {
  id: string;
  path: string;
  displayName: string;
  style: string;
  links: string[];
}

const DOCS_ROOT = resolve(__dirname, '../..');

// Get color style based on file path
const getNodeStyle = (filePath: string): string => {
  const rel = relative(DOCS_ROOT, filePath);
  
  if (rel.includes('core-concepts/')) return 'stroke:#f33,stroke-width:2px';
  if (rel.includes('architecture/')) return 'stroke:#33f,stroke-width:2px';
  if (rel.includes('guides/')) return 'stroke:#3f3,stroke-width:2px';
  if (rel.includes('planning/')) return 'stroke:#ff3,stroke-width:2px';
  if (rel.includes('specifications/')) return 'stroke:#f3f,stroke-width:2px';
  if (rel.includes('features/')) return 'stroke:#f93,stroke-width:2px';
  if (rel.includes('reference/')) return 'stroke:#666,stroke-width:2px';
  if (rel.includes('archive/')) return 'stroke:#963,stroke-width:2px';
  if (basename(filePath) === 'README.md') return 'stroke-width:3px';
  
  return '';
};

// Build node map using breadth-first traversal
const buildNodeMap = (
  startFile: string,
  maxDepth?: number
): Map<string, FileNode> => {
  let nodeId = 0;
  
  return analyzeLinksBreathFirst(
    startFile,
    maxDepth ?? Infinity,
    '*.md',
    (path: string, links: string[]) => {
      const rel = relative(DOCS_ROOT, path);
      const displayName = rel || basename(path);
      const style = getNodeStyle(path);
      
      return {
        id: `node${nodeId++}`,
        path,
        displayName,
        style,
        links,
      };
    }
  );
};

// Generate Mermaid diagram
const generateDiagram = (startFile: string, maxDepth?: number): string => {
  const nodeMap = buildNodeMap(startFile, maxDepth);
  
  const lines: string[] = [
    'flowchart TD',
    '  %% Documentation Structure Diagram',
    `  %% Generated by: generate-doc-diagram.ts`,
    `  %% Date: ${new Date().toISOString().split('T')[0]}`,
    '',
  ];
  
  // Output all nodes in breadth-first order (level by level)
  interface DepthNode {
    path: string;
    depth: number;
  }
  
  const depthLevels: Array<Array<DepthNode>> = [];
  const visited = new Set<string>();
  const queue: DepthNode[] = [{ path: startFile, depth: 0 }];
  
  // Collect nodes into depth levels using BFS
  while (queue.length > 0) {
    const current = queue.shift()!;
    
    if (visited.has(current.path)) continue;
    visited.add(current.path);
    
    const node = nodeMap.get(current.path);
    if (!node) continue;
    
    // Ensure depth level array exists
    if (!depthLevels[current.depth]) {
      depthLevels[current.depth] = [];
    }
    
    // Add to current depth level
    depthLevels[current.depth].push(current);
    
    // Queue all children for next depth level
    for (const link of node.links) {
      if (!visited.has(link)) {
        queue.push({ path: link, depth: current.depth + 1 });
      }
    }
  }
  
  // Output nodes level by level (breadth-first)
  for (const level of depthLevels) {
    for (const { path } of level) {
      const node = nodeMap.get(path);
      if (!node) continue;
      
      // Output node definition
      lines.push(`  ${node.id}["${node.displayName.replace(/"/g, '\\"')}"]`);
      if (node.style) {
        lines.push(`  style ${node.id} ${node.style}`);
      }
      
      // Output connections to children
      for (const link of node.links) {
        const linkNode = nodeMap.get(link);
        if (linkNode) {
          lines.push(`  ${node.id} --> ${linkNode.id}`);
        }
      }
    }
  }
  
  // Add legend
  lines.push('');
  lines.push('  %% Legend');
  lines.push('  legend["ðŸ“š Legend"]');
  lines.push('  style legend stroke:#333,stroke-width:2px,stroke-dasharray: 5 5');
  lines.push('  legend --> core["ðŸ”´ Core Concepts"]');
  lines.push('  style core stroke:#f33,stroke-width:2px');
  lines.push('  legend --> arch["ðŸ”µ Architecture"]');
  lines.push('  style arch stroke:#33f,stroke-width:2px');
  lines.push('  legend --> guide["ðŸŸ¢ Guides"]');
  lines.push('  style guide stroke:#3f3,stroke-width:2px');
  lines.push('  legend --> plan["ðŸŸ¡ Planning"]');
  lines.push('  style plan stroke:#ff3,stroke-width:2px');
  lines.push('  legend --> spec["ðŸŸ£ Specifications"]');
  lines.push('  style spec stroke:#f3f,stroke-width:2px');
  lines.push('  legend --> feat["ðŸŸ  Features"]');
  lines.push('  style feat stroke:#f93,stroke-width:2px');
  
  return lines.join('\n');
};

// Parse command line arguments
const parseArgs = (args: string[]): Options => {
  const options: Options = {
    start: join(DOCS_ROOT, '../.github/copilot-instructions.md'),
  };
  
  for (let i = 0; i < args.length; i++) {
    switch (args[i]) {
      case '--start':
        options.start = args[++i];
        break;
      case '--depth':
        options.depth = parseInt(args[++i], 10);
        break;
      case '-h':
      case '--help':
        options.help = true;
        break;
    }
  }
  
  return options;
};

// Show help
const showHelp = () => {
  console.log(`
Usage: bun run generate-doc-diagram.ts [--start <path>] [--depth <number>]

Generate Mermaid flowchart visualization of documentation structure.

Options:
  --start <path>      Starting documentation file (default: .github/copilot-instructions.md)
  --depth <number>    Maximum recursion depth (default: unlimited)
  -h, --help         Show this help message

Examples:
  # Full documentation diagram from copilot instructions
  bun run generate-doc-diagram.ts

  # Start from main docs README
  bun run generate-doc-diagram.ts --start docs/README.md

  # Limited depth for overview (2 levels)
  bun run generate-doc-diagram.ts --start docs/README.md --depth 2

  # Save to file
  bun run generate-doc-diagram.ts --start docs/README.md > doc-structure.mermaid

Output:
  Valid Mermaid flowchart diagram code that can be:
  - Pasted into GitHub markdown
  - Used in documentation files
  - Rendered with Mermaid CLI or online tools
`);
};

// Main
const main = () => {
  const options = parseArgs(process.argv.slice(2));
  
  if (options.help) {
    showHelp();
    process.exit(0);
  }
  
  // Resolve start file path
  const startFile = resolve(options.start);
  
  if (!existsSync(startFile)) {
    console.error(`Error: File not found: ${startFile}`);
    process.exit(1);
  }
  
  // Generate and output diagram
  const diagram = generateDiagram(startFile, options.depth);
  console.log(diagram);
  
  // Stats to stderr
  const rel = relative(DOCS_ROOT, startFile) || basename(startFile);
  console.error(`\nâœ“ Diagram generated successfully!`);
  console.error(`Starting from: ${rel}`);
  console.error(`Max depth: ${options.depth ?? 'unlimited'}`);
  console.error('\nCopy the output above and paste into:');
  console.error('  - GitHub markdown (will render automatically)');
  console.error('  - Mermaid Live Editor: https://mermaid.live');
  console.error('  - Documentation files with Mermaid support');
};

main();
